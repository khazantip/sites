## Задание 2

### 1. React-приложение

#### 1.1. Создание проекта

В проводнике открываем директорию, в которой необходимо создать папку с проектом. В этой директории открываем контекстное меню `Ctrl + Shift + ПКМ (правая кнопка мыши)`. Выбираем пункт `Открыть окно PowerShell здесь`. Далее, в командной строке пишем следующую команду:

- `npx create-react-app <название проекта>` - создает проект и начальные файлы для работы (в том числе, git-репозиторий )

#### 1.2. Открытие проекта

Открываем VS Code, выбираем `Файл (File)` -> `Открыть папку (Open folder)`. В открывшемся окне выбираем директорию с нашим проектом `<название проекта>` и подтверждаем выбор.

#### 1.3. Подготовка проекта

Удаляем файлы:

- `src/App.test.js`
- `src/setupTests.js`
  Переименовываем файлы:
- `src/App.js` -> `src/App.jsx`

Открываем консоль путём нажатия клавиш `Ctrl + ~ (Ё)`. Устанавливаем библиотеки:

- `npm i react-router-dom` - для работы с навигацией
- `npm i tailwindcss` - для работы с Tailwind (по желанию)

Если выбрали Tailwind, то его нужно инициализировать:

- `npx tailwindcss init` - команда создает файл `tailwind.config.js` в корне проекта
  В файл необходимо поместить код:

```js
/**  @type  {import('tailwindcss').Config}  */
module.exports = {
  content: ["src/**/*.{js,jsx}"],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

В **начало** файла `index.css` код:

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

Создаём директории:

- `src/components` - для компонент (кнопки, поля ввода и т. п.)
- `src/layouts` - для шаблонов страниц
- `src/pages` - для содержимого страниц

#### 1.4. Наполнение сайта

Для каждого компонента создаем отдельную директорию `src/components/<имя компонента>` с файлами `src/components/<имя компонента>/index.jsx` и `src/components/<имя компонента>/index.css` (css-файл, если не используем Tailwind)
В файл `src/components/<имя компонента>/index.jsx` помещаем следующий код:

```js
import './index.css';

const <имя компонента> = () => {
	return (...);
}

export default <имя компонента>;
```

Для шаблонов создаем отдельную директорию `src/layouts/<имя шаблона>Layout` с файлами `src/layouts/<имя компонента>Layout/index.jsx` и `src/layouts/<имя компонента>Layout/index.css`
В файл `src/layouts/<имя компонента>Layout/index.jsx` помещаем следующий код:

```js
import { Outlet } from  'react-router-dom';
import  './index.css';

const Button = () => {
	...
	return (
		...
		<Outlet /> // на это место будет помещен некоторый контент
		...
	);
}

export  default  Button;
```

В файле `index.js` создаем роутер:

```js
const router = createBrowserRouter([
	{
		path:  '/',
		element:  <RootLayout  />,
		children:  [
			{
				path:  '/',
				element:  <HomePage  />
			},
			...
		],
	},
	...
]);
```

Здесь `RootLayout` - шаблон из директории `src/layouts`, а `HomePage` - страница из `src/pages`, которая была собрана из компонент, находящихся в `src/components`. Всё содержимое страницы `HomePage` будет помещено вместо компонента `Outlet`, который был размещён внутри шаблона `RootLayout`

Заставляем React рендерить наш роутер:

```js
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>
);
```

#### 1.6. Передача параметров в роутере

Для передачи параметров в `react-router-dom` существует два метода:

##### 1.6.1. Переменная пути

Для использования переменной пути в роутере необходимо в путь элемента роутера вставить название переменной после двоеточия, например:

```js
{
	path:  '/:id',
	element:  <ProductCard  />
},
```

Здесь указана переменная пути `id`, которой соответствует компонент некоторого продукта `ProductCard`. При этом в самом компоненте для получения переменной пути, по которому этот продукт был открыт, необходимо использовать хук `useParams`, который предоставляет объект, поля которого являются переменными пути. Например, для такого объекта роутера:

```js
{
	path:  '/:department/:id',
	element:  <EmployeeCard  />
},
```

И компонента `EmployeeCard`:

```js
import { useParams } from 'react-router-dom';
import  './index.css';

const EmployeeCard = () => {
	// константа содержит в себе объект с полями `department` и `id`
	const pathVariables = useParams();

	// или вариант с деструктуризацией:
	const { department, id } = useParams();

	...
	return (
		...
	);
}

export  default  EmployeeCard;
```

##### 1.6.2. Параметры запроса

Параметры запроса представляют из себя пары ключ-значение, которые указаны в конце пути. Параметры запроса указываются после знака `?` и разделяются символом `&`, например:

`https://www.wildberries.ru/catalog/.../pizhamy-i-sorochki?sort=popular&page=1&xsubject=1935`

Данная ссылка содержит параметры запроса:

- `sort` со значением `popular`
- `page` со значением `1`
- `xsubject` со значением `1935`

Для получения параметров запроса используется хук `useSearchParams`. Он предоставляет пользователю состояние, содержащее объект, полями которого являются сами параметры. Рассмотрим пример, где объект роутера представлен таким образом:

```js
{
	path:  '/catalog',
	element:  <CatalogPage  />
},
```

А компонент `CatalogPage` представлен таким образом:

```js
import { useSearchParams } from 'react-router-dom';
import  './index.css';

const CatalogPage = () => {
	const [searchParams, setSearchParams] = useSearchParams();

	...
	return (
		...
	);
}

export  default  CatalogPage;
```

При этом, если мы перейдем по ссылке `.../catalog?sort=latest`, то в состоянии `searchParams` будет находиться объект следующего вида:

```js
{
	sort: 'latest',
}
```

При помощи функции `setSearchParams` можно добавлять или изменять параметры запроса. Например, если мы находимся на странице `.../catalog?sort=latest` и вызываем функцию `setSearchParams({ sort: 'newest' })`, то в ссылке отобразится новое значение параметра `sort`: `.../catalog?sort=newest`

#### 1.5. Предметная область

Создайте сайт, представляющий маркетплейс автомобилей. На главной странице представлен каталог с карточками автомобилей. При нажатии на карточку происходит переход в детальную карточку конкретного автомобиля.

### Dockerfile

Создаём Dockerfile для проекта с содержимым:

```Dockerfile
FROM node:latest
COPY . /app
WORKDIR /app
RUN yarn install
EXPOSE 3000
CMD ["npm", "run", "start"]
```

### Репозиторий

Создаём репозиторий на [GitHub](https://github.com). С названием `culinary-blog`, например

Выкладываем свой проект на удаленный репозиторий:

```bash
git init
git add .
git commit -m "init"
git remote add origin <ссылка на ваш репозиторий>
git push origin master
```

На виртуальной машине клонируем свой проект из GitHub:

```bash
git clone <ссылка на ваш репозиторий>
```

После каждого изменения в своём проекте в Visual Studio Code необходимо фиксировать изменения в системе контроля версий. Для этого необходимо последовательно выполнять команды:

1. `git add .` - добавление всех измененных файлов в так называемый `stage`. Там хранятся файлы, которые готовы к коммиту
2. `git commit -m "сообщение коммита"` - создание коммита. Коммит хранит изменения кода. При создании коммита обязательно указать сообщение - это параметр `-m` со строковым значением, например, `"сообщение коммита"`
3. `git push origin master` - отправка изменений в удаленный репозиторий. Все коммиты, которые Вы сделали ранее будут отправлены в удаленный репозиторий с названием `origin` (это тот, который мы добавили при инициализации репозитория) в ветку с названием `master`

При этом на виртуальной машине необходимо выполнить команду `git pull`. Она обновляет локальный репозиторий изменениями из удаленного репозитория. Команду необходимо выполнять в папке склонированного репозитория

### Сборка и запуск

Собираем проект из Dockerfile:

```bash
sudo docker build -t culinary-blog .
```

Здесь параметр `-t` со значением `culinary-blog` означает, что мы задаём образу контейнера название `culinary-blog`. Точка в конце команды означает, что мы ищем Dockerfile в текущей директори. Соответственно, команду необходимо выполнять в папке склонированного репозитория

Запускаем собранный Docker-образ:

```bash
sudo docker run -d -p 80:3000 culinary-blog
```

Здесь параметр `-d` означает `detached`, то есть отсоединённый (после запуска мы выйдем из контейнера).

Переходим в браузере на свой IP-адрес и просматриваем созданный кулинарный блог
